import os ,threading ,asyncio ,time

thread_loop = asyncio.new_event_loop()


def _start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

ret = None
async def cout(a,b):
    index = 1

    while True:
        print(a ," 开始任务 = ",index)
        await asyncio.sleep(1)
        print("bbbbb")

        # if index%2 == 0:
            # asyncio.run_coroutine_threadsafe(cout(index, 2), thread_loop)  # 传参必须是协程对象
            # print("start cout ")

        if index%10 == 0:
            b = asyncio.run_coroutine_threadsafe(back(2), thread_loop)  # 传参必须是协程对象
            print("start cout =",ret)

        print("ret = " ,b)

        index +=1


async  def  back(dict):
    print("send dict" )
    await asyncio.sleep(5)
    print("get value back")
    return "aaaaaaaaaaa"

# ------------------------------
def check():
    pass

async def check1(_dict,sleeptime,times = 0):
    index = 0
    while True:

        # 根据类型选择是否要发送数据
        print("check1")

        await asyncio.sleep(sleeptime)

        #在次进行查询结果，结果需要对比时间。时间不匹配进行重试，超过几次直接返回错误
        print("123445")

        index +=1

        if index == 6:
            return {"a":1}

async def check2(_dict,sleeptime,times = 0):
    times +=1
    if times == 6:
        return {"a": 1}

        # 根据类型选择是否要发送数据
    print("check1")
    global result

    SendCheckFlag = True

    while True:
        # 执行一次检查
        pass

        await asyncio.sleep(sleeptime)

        #在次进行查询结果，结果需要对比时间。时间不匹配进行重试，超过几次直接返回错误
        if SendCheckFlag:
            print("123445")
            result =  asyncio.run_coroutine_threadsafe(check2(0, 3,times), thread_loop)  # 传参必须是协程对象
            SendCheckFlag = False


        if result._state == "FINISHED":
            print("times=",times, result.result())
            return  result.result()


def Send(_dict):
    pass

taskdata = {"data":{},"check":lambda: check(),"operatetype": 1}

async def task(_dict,sleeptime):
    SendFlag = True
    if taskdata['operatetype'] == "re":
        ReSendFlag = True
    else:
        ReSendFlag = False

    SendCheckFlag = True

    global result
    result = None


    while True:

        # 自己　进行一个计时
        print("进行计时,还要等待检查任务返回　result　＝　",result)

        # 执行单次任务 ,或根据实际情况　触发多次任务
        if SendFlag or ReSendFlag:
            # ret = Send(_dict['data'])
            # SendFlag = True if ret == 0 else False
            pass

        await asyncio.sleep(sleeptime)

        # 去实现一次检查　，检查可以是异步的也可以是同步的
        # 异步的是发送请求，同步的是直接查询共享内存的数据
        if SendCheckFlag:
            result = asyncio.run_coroutine_threadsafe(check2(0,5), thread_loop)  # 传参必须是协程对象
            SendCheckFlag = False

        if result._state == "FINISHED":
            print("aaa",result.result() )
            break


        # print(len(thread_loop._scheduled))

    print("task over")


if __name__ == '__main__':

    threading.Thread(target=_start_loop , args=(thread_loop,)).start()
    asyncio.run_coroutine_threadsafe(task(1,0.5), thread_loop)  # 传参必须是协程对象
